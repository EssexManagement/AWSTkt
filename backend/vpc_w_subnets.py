from aws_cdk import (
    aws_ec2,
    aws_ssm as ssm,
    App, Stack, RemovalPolicy, Duration,
    CfnParameter,
    CfnOutput,
    Tag, CfnTag,
    Fn,
    aws_logs,
)
from constructs import Construct

import constants
import common.cdk.aws_names as aws_names
from cdk_utils.CloudFormation_util import get_tags_as_array

class VpcWithSubnetsConstruct(Construct):

    @property
    def vpc(self) -> aws_ec2.IVpc:
        return self._vpc

    @property
    def private_subnet_ids(self) -> list[str]:
        return self._priv_subnet_ids

    def __init__(self, scope: Construct, construct_id: str,
        tier :str,
        aws_env :str,
        git_branch :str,
        cdk_app_name :CfnParameter,
        **kwargs
    ) -> None:
        """ Other than the usual triplet (tier, aws_env/aws_acct and git_branch) ..
            pass in param #4 (of Python-type: aws_cdk.CfnParameter) ..
               .. so that the CLoudFormation-generated is generic.
        """
        super().__init__(scope, construct_id, **kwargs)
        stk = Stack.of(self)

        # tier = self.node.try_get_context("tier")
        # git_branch = constants.get_git_branch( tier=tier )
        # aws_env = tier if tier in constants.STD_TIERS else constants.DEV_TIER ### ["dev", "int", "uat", "prod"]:
        print( f"tier = '{tier}' within "+ __file__ )
        print( f"git_branch = '{git_branch}' within "+ __file__ )
        print( f"aws_env = '{aws_env}' within "+ __file__ )

        private_subnet_cidr :any = self.node.try_get_context("private_subnet_cidr")
        print(f"private_subnet_cidr = '{private_subnet_cidr}'")
        if private_subnet_cidr.get(tier):
            private_cidr_block = private_subnet_cidr[tier]
        elif private_subnet_cidr.get('default'):
            private_cidr_block = private_subnet_cidr['default']
        else:
            raise ValueError(f"cdk.json file is MISSING value for `private_subnet_cidr`-- BOTH for the tier=`{tier} as well as for `default`.")
        print(f"private_subnet_cidr = '{private_cidr_block}'")

        cidr_ctx :any = self.node.try_get_context("cidr")
        print(f"cidr_ctx = '{cidr_ctx}'")
        if cidr_ctx.get(tier):
            cidr_block = cidr_ctx[tier]
        elif cidr_ctx.get('dev'):
            cidr_block = cidr_ctx['dev']
        else:
            raise ValueError(f"cdk.json file is MISSING value for `cidr`-- BOTH for the tier=`{tier} as well as for `dev`.")
        print(f"cidr_block = '{cidr_block}'")

        if tier not in constants.STD_TIERS:
            print( f"For tier='{tier}', --NOT-- creating a new VPC. Instead RE-USING dev-environment's VPC='{aws_names.get_vpc_name(tier)}' // "+ __file__)
            self._vpc = aws_ec2.Vpc.from_lookup(self, f"vpcLookup", vpc_name=aws_names.get_vpc_name(tier))
        else:

            # cidr_block = '192.168.50.0/24'
            ### NIST 800-53 finding -- VPC Flow Logs are mandatory, else HIGH-finding
            flowlogs_name = f"{cdk_app_name.default}-{tier}-VPC"
            # flowlogs_name = Fn.join("-", [cdk_app_name.value_as_string, tier, "VPC"])
            flow_logs = {
                tier: aws_ec2.FlowLogOptions(
                    destination=aws_ec2.FlowLogDestination.to_cloud_watch_logs(
                        log_group=aws_logs.LogGroup( scope = self, id="VPCFlowLogs",
                            log_group_name = f"/aws/VPC/{flowlogs_name}/FlowLogs",
                            #### !! Warning !! if you set retention to RETAIN_ON_DELETE, remember to REMOVE the name of log-grp above!!!
                            removal_policy=RemovalPolicy.DESTROY, ### Landing Zone for Prod also should be provided and NOT created by App.
                            log_group_class = aws_logs.LogGroupClass.STANDARD,
                            retention=aws_logs.RetentionDays.SEVEN_YEARS,
                        )
                        ## ,iam_role = .. automatically generated by CDK
                    ),
                    log_format=[aws_ec2.LogFormat.ALL_DEFAULT_FIELDS],
                    max_aggregation_interval=aws_ec2.FlowLogMaxAggregationInterval.TEN_MINUTES,
                    traffic_type=aws_ec2.FlowLogTrafficType.ALL,
                )
            }
            self._vpc = aws_ec2.Vpc( self, id="VPC",
                vpc_name=aws_names.get_vpc_name(tier),
                # cidr=_block,  ### Deprecated. Use ip_addresses as shown below.
                ip_addresses=aws_ec2.IpAddresses.cidr(cidr_block),
                max_azs = 2,
                nat_gateways = 1,
                flow_logs = flow_logs,
                subnet_configuration = [
                    ### RuntimeError: If you configure PRIVATE subnets in 'subnetConfiguration', you must also configure PUBLIC subnets
                    ###          to put the NAT gateways into
                    aws_ec2.SubnetConfiguration(
                        name="public",
                        # name=aws_names.get_subnet_name( tier, "public"),
                        cidr_mask=24,
                        reserved=False,
                        subnet_type=aws_ec2.SubnetType.PUBLIC,
                    ),
                    aws_ec2.SubnetConfiguration(
                        name="private",
                        # name=aws_names.get_subnet_name( tier, "private"),
                        cidr_mask=24,
                        reserved=False,
                        subnet_type=aws_ec2.SubnetType.PRIVATE_WITH_EGRESS,
                    ),
                    # aws_ec2.SubnetConfiguration(
                    #     name="DB",
                    #     cidr_mask=24,
                    #     reserved=False,
                    #     subnet_type=aws_ec2.SubnetType.PRIVATE_ISOLATED,
                    # ),
                ],
                restrict_default_security_group = True,
                create_internet_gateway = False,
                enable_dns_hostnames = True,
                enable_dns_support = True,
                # gateway_endpoints = .. ### see this taken care of below.
            )
            self._priv_subnet_ids = [subnet.subnet_id for subnet in self._vpc.private_subnets]

            # ### As of 2025-January for CDK-Version 2.173.4 .. Tagging of VPC Interface-EndPoints is --NOT-- supported in CDK.
            # ### Hence the following workaround.
            # tagsarr = []
            # for k, v in get_tags_as_json(tier, aws_env, git_branch).items():
            #     tagsarr.append( CfnTag( key=k, value=v ) )

            ### NIST 800-53 finding -- VPC Interface Endpoints are mandatory, else MEDIUM-finding
            list_of_endpts = []
            endpt = self._vpc.add_interface_endpoint("CloudWatchLogsEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.CLOUDWATCH_LOGS,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("EC2Endpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.EC2,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("EC2MessagesEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.EC2_MESSAGES,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("SSMEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.SSM,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("SSMMessagesEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.SSM_MESSAGES,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("SSMContactsEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.SSM_CONTACTS,
                lookup_supported_azs = True, ### <--- Unique to this type of EndPt
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("SSMIncidentsEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.SSM_INCIDENTS,
                lookup_supported_azs = True, ### <--- Unique to this type of EndPt
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("ECRApiEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.ECR,
            ); list_of_endpts.append( endpt )
            endpt = self._vpc.add_interface_endpoint("ECRDockerEndpoint",
                service=aws_ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER,
            ); list_of_endpts.append( endpt )
            ### As of 2025-January for CDK-Version 2.173.4 .. Tagging of VPC Interface-EndPoints is --NOT-- supported in CDK.
            ### Hence the following workaround.
            for ep in list_of_endpts:
                endptCfn :aws_ec2.CfnVPCEndpoint = ep.node.default_child
                endptCfn.add_property_override("Tags",  get_tags_as_array(tier, aws_env, git_branch))

            count = 1
            for psub in self.private_subnet_ids:
                # parameter_name = Fn.join('/', ['/', cdk_app_name.value_as_string, aws_env, tier, 'private-subnet-'+str(count)] )
                parameter_name = f'/{aws_env}/{tier}/private-subnet-'+str(count)
                ssm.StringParameter(self, 'private-subnet-'+ str(count),
                    string_value = psub,
                    parameter_name = parameter_name,
                    simple_name = False  # Because we're using '/' in the parameter name
                )
                count += 1

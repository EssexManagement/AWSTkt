"""CDK construct for protecting API Gateway and CloudFront-distribution"""

import typing
from typing import Optional, Literal
from datetime import datetime, timezone

from os import path
import pathlib
import string
import random
import base64
from functools import partial

from constructs import Construct
from aws_cdk import (
    Duration,
    Stack,
    RemovalPolicy,
    aws_logs as logs,
    aws_iam,
    aws_apigateway as apigateway,
    aws_cloudfront,
    aws_wafv2,
    aws_secretsmanager,
    aws_lambda,
    aws_events,
    aws_events_targets,
)

import constants
import common.cdk.constants_cdk as constants_cdk
from common.cdk.standard_lambda import StandardLambda

### ---------------------------------------------------------------------------------------------
### .............................................................................................
### ---------------------------------------------------------------------------------------------

# Get current UTC date as string in YYYY-MM-DD format
utc_date_only = datetime.now(timezone.utc).strftime('%Y-%m-%d')

# token_length = 64
# chars = string.ascii_letters + string.digits + "./"
# x_origin_verify_hdr_token_value :str = ''.join(random.choice(chars) for _ in range(token_length))
# x_origin_verify_hdr_token_filename = "/tmp/http-hdr-token"
# ### Save the token to the above file
# with open(x_origin_verify_hdr_token_filename, "w") as file:
#     file.write(x_origin_verify_hdr_token_value)

### ---------------------------------------------------------------------------------------------
### .............................................................................................
### ---------------------------------------------------------------------------------------------


class BackendWAFConstruct(Construct):
    """
        CDK construct for creating WAF-ACL w/ WAF-Rules mimicking CBIIT's Firewall-managed rules.
        This new TIER-specific WAF-ACL will be associated with the TIER-specific NCCR --PUBLIC-- RestAPI.
        It contains:-
            AWS-Managed RuleSets +
            One Custom-Rule to insert a custom HttpHeader (so that Backend-APIGW's WAF will only allow Apis for traffic that has this http-header)
            One Custom-Rule to throttle per-user (to prevent malware-infected end-user-laptops from beating the solution)
    """

    @staticmethod
    def origin_token_http_header_name() -> str:
        """ Static method that returns a hardcoded-constant to be shared across Constructs"""
        return 'x-origin-verify'

    @staticmethod
    def x_origin_verify_hdr_token_value() -> str:
        return utc_date_only
    # @staticmethod
    # def x_origin_verify_hdr_token_value(self) -> str:
    #     with open(x_origin_verify_hdr_token_filename, "r") as file:
    #         return file.read()
    #     raise "Unable to read the X-Origin Http-hdr-token generated by BACKEND-pipeline."

    @staticmethod
    def waf_acl_name( tier :str ) -> str:
        waf_acl_name = constants.CDK_APP_NAME + "-Regional-Custom-WAFACL-"+ tier
        return waf_acl_name

    @staticmethod
    def waf_rule_name() -> str:
        """ Static method that returns a hardcoded-constant to be shared across Constructs"""
        return "HttpHeaderToken-"+BackendWAFConstruct.origin_token_http_header_name()

    @property
    def waf_acl_id(self) -> str:
        return self._waf_acl.attr_id

    @property
    def waf_acl_arn(self) -> str:
        return self._waf_acl.attr_arn

    @property
    def waf_acl(self) -> aws_wafv2.CfnWebACL:
        return self._waf_acl

    # @property
    # def x_origin_verify_hdr_secret(self) -> aws_secretsmanager.ISecret:
    #     return self._x_origin_verify_hdr_secret
    #     """
    #        This Secret needs to be accessible in the frontend_2nd_origin construct.
    #        This Secret's value must be readable over there.
    #        Hence, this property returns `Secret` and NOT `ISecret`.
    #     """

    def __init__(
        self,
        scope: "Construct",
        construct_id: str,
        tier :str,
    ) -> None:
        super().__init__(scope=scope, id=construct_id)
        stk = Stack.of(self)

        ### -------------------
        waf_rule_priority = 0
        effective_tier = tier if (tier in constants.STD_TIERS or tier in constants.ACCT_TIERS) else "dev"
        nonprod_or_prod = constants_cdk.TIER_TO_AWSENV_MAPPING[ effective_tier ]

        waf_rules :list[aws_wafv2.CfnWebACL.RuleProperty] = [ ]

        ### HOW-TO: aws wafv2 list-available-managed-rule-groups --scope REGIONAL
        aws_managed_waf_rule_groups = [
            # "AWSManagedRulesCommonRuleSet", ### Limits payloads to just 8KB.  https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-baseline.html#aws-managed-rule-groups-baseline-crs
            "AWSManagedRulesAdminProtectionRuleSet",
            "AWSManagedRulesKnownBadInputsRuleSet",  ### prevents `localhost` in host-header https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-baseline.html#aws-managed-rule-groups-baseline-known-bad-inputs

            ##__ "AWSManagedRulesSQLiRuleSet",
            ##__ "AWSManagedRulesLinuxRuleSet",
            ##__ "AWSManagedRulesUnixRuleSet",
            ##__ "AWSManagedRulesWindowsRuleSet",
            ##__ "AWSManagedRulesPHPRuleSet",
            ##__ "AWSManagedRulesWordPressRuleSet",

            "AWSManagedRulesAmazonIpReputationList",
            "AWSManagedRulesAnonymousIpList",
            "AWSManagedRulesBotControlRuleSet",

            ##__ "AWSManagedRulesATPRuleSet",
            ##__ "AWSManagedRulesACFPRuleSet",
        ]

        ### -------------------

        # self._x_origin_verify_hdr_secret = aws_secretsmanager.Secret(
        #     scope=self,
        #     id="XOriginVerifyHdrSecret",
        #     secret_name = stk.stack_name+"-X-Origin-Verify-Hdr",
        #     description = f"Tier={stk.stack_name} -- Secret for X-Origin-Verify-Hdr header used exclusively between CloudFront and WAF-infront-of-APIGW",
        #     generate_secret_string = aws_secretsmanager.SecretStringGenerator(
        #         exclude_punctuation=True,
        #         include_space=False,
        #         password_length=64,
        #         require_each_included_type=True
        #     ),
        #     removal_policy = RemovalPolicy.DESTROY,
        # )
        ### do -NOT- add rotation to the above secret, as we want the Lambda be inside a VPC.   Instead, see XOriginVerifyCloudFrontHdrTokenRotationLambdaConstruct()
        # x_origin_verify_hdr_secret_arn :str = self.node.try_get_context("apigw")["x-origin-verify-hdr-secret-arn"]
        # if x_origin_verify_hdr_secret_arn == None or x_origin_verify_hdr_secret_arn.strip(" \t?") == "":
        #     x_origin_verify_hdr_secret = None
        # else:
        #     x_origin_verify_hdr_secret = aws_secretsmanager.Secret.from_secret_complete_arn(self, "XOriginVerifyHdrSecret", x_origin_verify_hdr_secret_arn)

        ### -------- add AWS-Managed WAF-Rules mimicking Enterprise Firewall-Manager-managed rules ------
        for mgd_waf_rule_name in aws_managed_waf_rule_groups:
            new_rule = aws_wafv2.CfnWebACL.RuleProperty(
                ### https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-networking-policies/ensure-waf-prevents-message-lookup-in-log4j2
                name=mgd_waf_rule_name,
                # name="CKV_AWS_192: Ensure WAF prevents message lookup in Log4j2. See CVE-2021-44228 aka log4jshell",
                priority=waf_rule_priority,  # Adjust priority as needed based on other rules

                override_action=aws_wafv2.CfnWebACL.OverrideActionProperty(none={}),
                # action=aws_wafv2.CfnWebACL.RuleActionProperty(block={}),
                ### Ticket # 174551690600321
                ### If the rule-statement references a rule-group, you must -NOT- set this action setting, because the `actions` are already set on the rules inside the rule-group.
                ### "Action" is used only for rules whose statements do NOT reference a rule-group.
                ### Rule-statements that reference a rule-group include `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement`.
                ###      You must set either this `Action` setting or the rule's `OverrideAction`, but not both [1]:

                statement=aws_wafv2.CfnWebACL.StatementProperty(
                    managed_rule_group_statement=aws_wafv2.CfnWebACL.ManagedRuleGroupStatementProperty(
                        name=mgd_waf_rule_name,
                        vendor_name="AWS",
                        # vendor_name="AWS-FMS",  # For Enterprise Firewall-Manager managed CUSTOM Rules defined at AWS-Org Root-account.
                    )
                ),
                visibility_config=aws_wafv2.CfnWebACL.VisibilityConfigProperty(
                    cloud_watch_metrics_enabled=True,
                    metric_name=mgd_waf_rule_name,
                    sampled_requests_enabled=True,
                ),
            )
            waf_rules.append(new_rule)
            waf_rule_priority += 1

        ### -------------------
        ### Create the NEW custom WAF rule -- throttling each individual malware-user (Ticket # 2686 - rate-limiting by individual-user)
        ### oobox-WAF-capability: A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate.

        rate_waf_rule_name = "throttle-each-individual-user-ip"
        waf_rule_throttle_each_user = aws_wafv2.CfnWebACL.RuleProperty(
            name = rate_waf_rule_name,
            priority=waf_rule_priority,  # Adjust priority as needed based on other rules
            action=aws_wafv2.CfnWebACL.RuleActionProperty(block={}),
            # override_action is ONLY used for ManagedRuleGroups
            statement=aws_wafv2.CfnWebACL.StatementProperty(
                # not_statement=aws_wafv2.CfnWebACL.NotStatementProperty(
                    rate_based_statement=aws_wafv2.CfnWebACL.RateBasedStatementProperty(
                        ### https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wafv2-webacl-ratebasedstatement.html
                        evaluation_window_sec = 60, ### metrics calculated for every minute; Valid settings are 60, 120, 300, and 600.
                        limit = 600,  ### Note: minimum possible limit is 10/sec (Note: parallel-BDDs need 50x higher-amount)
                        ### To aggregate on only the IP-address or only the forwarded-IP-address, do -NOT- use `custom_keys`.
                        ### Instead, set the `aggregate_key_type` to `IP` or `FORWARDED_IP`.
                        aggregate_key_type="IP", ### individual aggregation keys: IP address or HTTP method
                        # aggregate_key_type="CUSTOM_KEYS", ### individual aggregation keys: IP address or HTTP method
                        # custom_keys="" ### https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_wafv2.CfnWebACL.RateBasedStatementProperty.html#aggregatekeytype
                        # scope_down_statement=aws_wafv2.CfnWebACL.StatementProperty(
                        #     ### https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wafv2-webacl-ratebasedstatement.html#cfn-wafv2-webacl-ratebasedstatement-scopedownstatement
                        # )
                    )
                # )
            ),
            visibility_config=aws_wafv2.CfnWebACL.VisibilityConfigProperty(
                ### https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wafv2-webacl-visibilityconfig.html
                cloud_watch_metrics_enabled=True,
                metric_name=rate_waf_rule_name,
                sampled_requests_enabled=True,
            ),
        )
        waf_rules.append(waf_rule_throttle_each_user)
        waf_rule_priority += 1

        ### -------------------
        ### Create the NEW custom WAF rule for the CustomHttpHeaderToken (limiting APIGW PUBLIC-RestApi to just CloudFront).
        waf_rule_XOriginVerify = aws_wafv2.CfnWebACL.RuleProperty(
            name = self.waf_rule_name(), ### property of this class, and is shared with LambdaConstruct as well as Frontend_2nd_origin construct
            priority=waf_rule_priority,  # Adjust priority as needed based on other rules
            action=aws_wafv2.CfnWebACL.RuleActionProperty(allow={}),
            # override_action is ONLY used for ManagedRuleGroups
            statement=aws_wafv2.CfnWebACL.StatementProperty(
                byte_match_statement=aws_wafv2.CfnWebACL.ByteMatchStatementProperty(
                    field_to_match=aws_wafv2.CfnWebACL.FieldToMatchProperty(
                        single_header={ "Name": self.origin_token_http_header_name() }
                    ),
                    positional_constraint="EXACTLY",
                    search_string = BackendWAFConstruct.x_origin_verify_hdr_token_value(),
                    # search_string=self._x_origin_verify_hdr_secret.secret_value.unsafe_unwrap(),
                    text_transformations = [
                        aws_wafv2.CfnWebACL.TextTransformationProperty(priority=0, type="NONE")
                        ### Set priority to 0 as it's the only transformation (in this Rule)
                    ],
                )
            ),
            visibility_config=aws_wafv2.CfnWebACL.VisibilityConfigProperty(
                ### https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wafv2-webacl-visibilityconfig.html
                cloud_watch_metrics_enabled=True,
                metric_name=self.waf_rule_name(),
                sampled_requests_enabled=True,
            ),
        )
        waf_rules.append(waf_rule_XOriginVerify)
        waf_rule_priority += 1

        ### ------ Create a new WAF-ACL -- just for this TIER -- using above WAF-rules -----
        self._waf_acl = aws_wafv2.CfnWebACL(
            scope_=self,
            id = tier,
            name = BackendWAFConstruct.waf_acl_name(tier),
            description = f"Custom WAF-ACL for {tier} in {nonprod_or_prod} created via CDK - with MANUAL-efforts to mimic Enterprise Firewall-Managed WAF-ACL entries",
            ### description must obey regular-expression pattern (No quotes at all): ^[\w+=:#@/\-,\.][\w+=:#@/\-,\.\s]+[\w+=:#@/\-,\.]$
            default_action=aws_wafv2.CfnWebACL.DefaultActionProperty(block={}),
            scope = "REGIONAL",
            visibility_config=aws_wafv2.CfnWebACL.VisibilityConfigProperty(
                cloud_watch_metrics_enabled=True, metric_name="OriginVerifyHeaderWAF", sampled_requests_enabled=True
            ),
            rules = waf_rules,
        )


    ### ---------------------------------------------------------------------------------------------
    ### .............................................................................................
    ### ---------------------------------------------------------------------------------------------

    def protect_api_w_waf( self,
        rest_api: apigateway.RestApi,
        apigw_stage_name: str,
    ) -> None:
        """
            Lookup cdk.json, for the ARN to the WAF-ACL.
            Associate the WAF-ACL to the APIGW.

            Note: Adding a custom-WAF-Rule to this WAF-ACL is done inside `backend/src/rotate_secret_cloudfront_apigw_hdr_token.py`
                  Why? 'cuz, there's only one way to change a WAF-ACL.  That is  thru AWS-SDk.  No CDK-support.
        """
        stk = Stack.of(self)

        # security_config = self.node.try_get_context("apigw")
        # if security_config and "WAF-ACL" in security_config:
        #     waf_acl_arn = security_config["WAF-ACL"]
        # else:
        #     waf_acl_arn = None
        # print(f"DEBUG: waf_acl_arn = '{waf_acl_arn}'")
        # if waf_acl_arn:
        #     if self.is_prod_account and C_ENV_PROD in waf_acl_arn:
        #         waf_acl_arn = waf_acl_arn[C_ENV_PROD]
        #     elif not self.is_prod_account and C_ENV_NON_PROD in waf_acl_arn:
        #         waf_acl_arn = waf_acl_arn[C_ENV_NON_PROD]
        #     else:
        #         waf_acl_arn = None
        # else:
        #     waf_acl_arn = None

        ### -------------------
        if self.waf_acl_arn:
            # given the ARN to a WAF-ACL, apply it to the above APIGW
            apigw_stage_arn = f"arn:{stk.partition}:apigateway:{stk.region}::/restapis/{rest_api.rest_api_id}/stages/{apigw_stage_name}"
            wafaclass = aws_wafv2.CfnWebACLAssociation( scope = self,
                id="wafv2ForAPIGW",
                web_acl_arn = self.waf_acl_arn,
                resource_arn = apigw_stage_arn,
            )
            wafaclass.add_dependency( rest_api.node.default_child ) # type: ignore
            wafaclass.add_dependency( rest_api.deployment_stage.node.default_child ) # type: ignore
        else:
            raise Exception("No WAF-ACL ARN defined, within BackendWAFConstruct")


### #########################################################################################################
### =========================================================================================================
### #########################################################################################################


class XOriginVerifyCloudFrontHdrTokenRotationLambdaConstruct(Construct):
    """
    Lambda to rotate the secrets-manager secret that stores the X-Origin-Verify Header-Token.
    Lambda will ALSO THEN update the CloudFront-distribution via boto3, to use this new header-value.
    Lambda will ALSO THEN update one specific pre-determined WAF-Rule (in a specified WAF-ACL) via boto3, to use this new header-value.

    Invoked by EventBridge Cron.
    """

    def __init__( self,
        cdk_scope: "Construct",
        construct_id: str,
        tier :str,
        waf_rule_name: str,
        waf_acl_arn: str,
        inside_vpc_lambda_factory :StandardLambda,
        eventbridge_busname: str = "default",
        # hdr_secret: sm.Secret,
        # waf_acl: aws_wafv2.CfnWebACL,
    ) -> None:
        super().__init__(cdk_scope, construct_id)

        stk = Stack.of(self)
        print(f"waf_rule_name='{waf_rule_name}'")
        print(f"waf_acl_arn='{waf_acl_arn}'")
        print(f"NCCR's Lambda specific to ROTATING Secret+UpdateCloudFront+UpdateWAFACLRule for {tier}")
        addl_lambda_env = {
            "TIER": tier,
            # "SECRET_ARN": hdr_secret.secret_arn,
            "WAF_ACL_ARN": waf_acl_arn,
            "WAF_RULE_NAME": waf_rule_name,
            # "LOG_LEVEL": LOG_LEVEL[self.real_tier],
        }

        self.lambda_name = f"{tier}_XOriginVerify-HdrTokenRotation"
        ### !!! NEVER use ABSOLUTE-PATHS for "entry" a.k.a. "path_to_lambda_src_root" !!!
        # entry = pathlib.Path(__file__).parent.parent / "src/rotate_secret_cloudfront_apigw_hdr_token"
        entry = pathlib.Path("backend/src")
        # entry = pathlib.Path("backend/src/rotate_secret_cloudfront_apigw_hdr_token")
        index = "rotate_secret_cloudfront_apigw_hdr_token/index.py"
        # index = "index.py"

        handler = "lambda_handler"
        description = "Rotate the secrets-manager secret that stores the X-Origin-Verify Header-Token, update CloudFront-distribution, update a WAF-Rule. This is Triggered via EventBridge-Cron"
        # handler_id = (index.replace(".py", "").replace("/","_") + '_' + handler).lower()
        # print( f"New ùúÜ: handler_id = '{handler_id}' and lambda_name = '{lambda_name}' handler_path={entry} / {index}" )

        self.xoriginverify_lambda = inside_vpc_lambda_factory.create_lambda(
            scope = self,
            lambda_name = self.lambda_name,
            index = index,
            handler = handler,
            description = description,
            path_to_lambda_src_root = entry,
            environment = addl_lambda_env,
            timeout = Duration.seconds(300),
            architecture = aws_lambda.Architecture.ARM_64,
        )

        ### Give Lambda the permissions it needs.
        self.xoriginverify_lambda.role.add_to_principal_policy( # type: ignore
            aws_iam.PolicyStatement(
                actions=[
                    "wafv2:GetWebACL",
                    "wafv2:UpdateWebACL",
                ],
                resources=[
                    waf_acl_arn,
                    # ### Context for the following ARN: A PoC: We created our own ACL, containing AWS-managed-Rule(s) + project-specific custom-Rule(s).
                    # ### Attention! Per CASE 174343402300399 (opened 2025-March-31) .. in a note sent -BY- -AWS- at Thu 2025-April-03 at 7pm ET ..
                    # ### We were explicitly told (in WRITING) by AWS-Support, to add the following */* into this policy.
                    f"arn:{stk.partition}:wafv2:{stk.region}:{stk.account}:regional/managedruleset/*/*",
                ],
            )
        )
        self.xoriginverify_lambda.role.add_to_principal_policy( # type: ignore
            aws_iam.PolicyStatement(
                actions=[
                    "cloudfront:GetDistributionConfig",
                    "cloudfront:UpdateDistribution",
                    "cloudfront:ListDistributions",
                    "cloudfront:ListTagsForResource",
                ],
                resources=["*"],
            )
        )
        self.xoriginverify_lambda.role.add_to_principal_policy( # type: ignore
            aws_iam.PolicyStatement(
                actions=["secretsmanager:GetRandomPassword"],
                resources=["*"],
            )
        )

        # get current hour as int --- at UTC timezone
        now = datetime.now( timezone.utc )
        hr = now.hour + 2
        minutes = now.minute
        ### Create a monthly cron-event to invoke the above lambda, once every 1st of the month
        if tier in constants.UPPER_TIERS:
            schedule=aws_events.Schedule.expression(expression=f"cron({minutes} {hr} * * ? *)")  ### UTC daily, but hr+minute is defined based on when Stack was deployed
        else:
            schedule=aws_events.Schedule.expression(expression=f"cron({minutes} 0/4 * * ? *)")  ### Once every four hours, starting 2 hrs from NOW.
        newcronrule = aws_events.Rule(
            scope=self,
            id="cron-_XOriginVerify-HdrTokenRotation",
            description=f"Monthly invoke Lambda {self.lambda_name}",
            targets=[aws_events_targets.LambdaFunction(self.xoriginverify_lambda)], # type: ignore
            schedule = schedule,
            # schedule=aws_events.Schedule.expression("cron(0 22 * * ? *)"),  ### Once a day at 6pm ET = 10pm UTC
            # schedule=aws_events.Schedule.expression(expression="cron(0  0  1 * ? *)"), ### On the 1st day of EVERY month
            # schedule=aws_events.Schedule.cron( day='1', hour='0', minute='0', month='*', year='*', week_day='*', ),
        )


### EoF
